	char		name[64]; // ROM name (no .zip, no path, example: afm_113b)
	UINT16      Version; // = v
	UINT16		fWidth;	// Frame width=fW
	UINT16		fHeight;	// Frame height=fH
	if v>=14
		UINT16		fWidthX;	// Frame width=fWX
		UINT16		fHeightX;	// Frame height=fHX
	UINT16		nFrames;	// Number of frames=nF
	if v>=14
		UINT16		nFramesX;	// Number of extra frames=nFX
	UINT16		noColors;	// Number of original colors=noC
	if v<14
		UINT16		ncColors;	// Number of colorization colors=nC
	UINT16		nCompMasks; // Number of dynamic masks=nM
	UINT16		nSprites; // Number of sprites=nS
	if v>=14
		UINT16		nSpritesX; // Number of extra sprites=nSX
	if v>=13
		UINT16		nBackgrounds; // Number of backgrounds=nB
	if v>=14
		UINT16		nBackgroundsX; // Number of BG for extra frames=nBX
		UINT16		nBGMasks; // Number of BG masks=nBM
		UINT16		nBGXMasks; // Number of BG masks for extra frames=nBXM
	if v>=20
		byte	is256x64; // is a 256x64 ROM
	UINT16		nDynaMasks; // Number of dynamic masks = nD
	if v>=14
		UINT16		nDynaMasksX;	// Number of dynamic masks for extra frames = nDX
		UINT32		lenColRotBuf; // Longueur en octets du buffer de ColorRotations = lCRB
		UINT32		lenColRotBufX; // Longueur en octets du buffer de ColorRotationsX = lCRBX
	if v>=18
		UINT16		nDynaSpriteMasks; // Number of dynamic masks for sprites = nDS
		UINT16		nDynaSpriteMasksX; // Number of dynamic masks for extra sprites = nDSX
	UINT32*		HashCode;	// UINT32[nF] hashcode/checksum
							// HashCode take into account the ShapeCompMode parameter converting any '2' or '3' into a '1'
	UINT8*		ShapeCompMode;	// UINT8[nF/8] bit=0 - full comparison (all 4 colors) bit=1 - shape mode (we just compare black 0 against all the 3 other colors as if it was 1 color)
	UINT8*		CompMaskID;	// UINT8[nF] Comparison mask ID per frame (255 if no mask for this frame)
	UINT8*		CompMasks;	// UINT8[nM*fW*fH/8] Bitmask for comparison
							// UINT8[nM*256*64/8] if is256x64 is TRUE
	// part for colorization
	if v<14
		UINT8*		cPal;		// UINT8[3*nC*nF] Palette for each colorized frames
		UINT8*		v1cFrames;		// UINT8[nF*fW*fH] Frames
	else
		UINT16*		cFrames;	// UINT16[nF*fW*fH] Colorized frames, if this frame has sprites, it is the colorized frame of the static scene, with no sprite
		UINT16*		FrameXIDs;	// UINT16[nF] Extra Frame ID for each original frame in the following array, 65535 if no extra frame
		UINT16*		cFramesX;	// UINT16[nFX*fWX*fHX] Colorized extra frames, if this frame has sprites, it is the colorized frame of the static scene, with no sprite
	UINT16*     DynaMaskIDs; // UINT16[nF] Dynamic mask ID per frame (65535 if no dynamic mask for this frame)
	UINT8*		DynaMasks;	// UINT8[nD*fW*fH] Mask for dynamic content for each frame.  The value (<MAX_DYNA_SETS_PER_FRAME) points to a sequence of 4/16 colors in Dyna4Cols. 255 means not a dynamic content.
	if v<14
		UINT8*		v1Dyna4Cols;	// UINT8[nDynaMasks*noC*16] noC colors per dynamic set
	else
		UINT16*     DynaMaskIDXs; // UINT16[nF] Dynamic mask ID per extra frame (65535 if no dynamic mask for this frame)
		UINT8*		DynaMasksX;	// UINT8[nDX*fWX*fHX] Mask for dynamic content for each frame.  The value (<MAX_DYNA_SETS_PER_FRAME) points to a sequence of 4/16 colors in Dyna4Cols. 255 means not a dynamic content.
		UINT16*		Dyna4Cols;	// UINT16[nD*noC*MAX_DYNA_SETS_PER_FRAMEN] noC colors per dynamic set
		UINT16*		Dyna4ColsX;	// UINT16[nDX*noC*MAX_DYNA_SETS_PER_FRAMEN] noC colors per dynamic set
	UINT8*		SpriteIDs; // UINT8[nF*MAX_SPRITES_PER_FRAME] ID of sprite used for each frame, 255 if no sprite
	if v>=14
		UINT16*     SpriteDescription; // UINT16[nS*128*128] Sprite drawing on 2 bytes per pixel:
			// - the first is the 4-or-16-color sprite original drawing (255 means this is out of the sprite) for Comparison step
			// - the second is the 64-color sprite for Colorization step
	else
		UINT8*      SpriteOriginal; // UINT8[nS*128*128] Sprite original drawing (255 means this is out of the sprite)
		UINT16*     SpriteColored; // UINT16[nS*128*128] Sprite colorized drawing 
		UINT16*		XSpriteIDs; // UINT16[nS] IDs of extra sprite used for each sprite, 65535 if no extra sprite
		UINT8*		XSpriteMasks;	// UINT8[nSX*MAX_SPRITE_WIDTH*MAX_SPRITE_HEIGHT/8] Bitmask for extra sprite
		UINT16*		XSpriteCols; // UINT16[nSX*MAX_SPRITE_WIDTH*MAX_SPRITE_HEIGHT] Drawing colors for extra sprite
	if v>=9
		if v>=14
			UINT8*		v1ColorRotations; // UINT8[nF*3*8] Old format for color rotations, 8 rotations (1st value is the position in the palette of the first color to rotate, 2nd value is the length of the rotation (number of colors), 3rd value is the length in ten milliseconds between 2 shifts)
		else
			UINT*		ColorRotDef; // UINT[nF * MAX_COLOR_ROTATIONN] Color rotations idx in ColorRotBuf (0xFFFFFFFF if no color rotation)
			UINT16*		ColorRotBuf; // UINT16[lCRB] Buffer of color rotations, 3 values per rotation (1st value is the length in colors, 2nd is the interval in ms between 2 shifts then all the colors of the rotation)
			UINT*		ColorRotDefX; // UINT[nF * MAX_COLOR_ROTATIONN] Color rotations for extra frames idx in ColorRotBuf (0xFFFFFFFF if no color rotation)
			UINT16*		ColorRotBufX; // UINT16[lCRBX] Buffer of color rotations, 3 values per rotation (1st value is the length in colors, 2nd is the interval in ms between 2 shifts then all the colors of the rotation)
		if v>=10
			UINT16*		SpriteDetAreas; // UINT16[nS*4*MAX_SPRITE_DETECT_AREAS] rectangles (left, top, width, height) as areas to detect sprites (left=0xffff -> no zone)
			UINT32*		SpriteDetDwords; // UINT32[nS*MAX_SPRITE_DETECT_AREAS] dword to quickly detect 4 consecutive distinctive pixels inside the original drawing of a sprite for optimized detection
			UINT16*		SpriteDetDwordPos; // UINT16[nS*MAX_SPRITE_DETECT_AREAS] offset of the above qword in the sprite description
			if v>=11
				UINT32*		TriggerID; // UINT32[nF] does this frame triggers any event ID, 0xFFFFFFFF if not
				if v>=12
					UINT16*		FrameSpriteBB; // UINT16[nF*MAX_SPRITES_PER_FRAME*4] The bounding boxes of the sprites described in SpriteIDs [minx,miny,maxx,maxy]
					if v>=13
						if v<14
							UINT8*		v1BackgroundFrames; // UINT8[nB*fW*fH] draw of the backgrounds
						else
							UINT16*		BackgroundFrames; // UINT16[nB*fW*fH] draw of the backgrounds
							UINT16*		BGXIDs;	// UINT16[nF] Extra BG ID for each original sized BG in the following array, 65535 if no extra BG
							UINT16*		BackgroundFramesX;	// UINT16[nBX*fWX*fHX] Colorized extra frames, if this frame has sprites, it is the colorized frame of the static scene, with no sprite
						UINT16*		BackgroundIDs;	// UINT16[nF] ID of the BG for each frame (65535 if no BG)
						if v<14
							UINT16*		BackgroundBB; // UINT16[4*nF] Bounding boxes of the backgrounds for each frame [minx,miny,maxx,maxy]
						else
							UINT16*		BackgroundMaskID; // UINT16[nF] Id of the mask used to draw the background for each frame in the buffer below (65535 if no mask for this frame, 65534 if the mask is empty)
							UINT8*		BackgroundMasks; // UINT16[nBM*fW*fH/8] Design of the masks for backgrounds 1 bit per pixel
							UINT16*		BackgroundXMaskID; // UINT16[nF] Id of the mask used to draw the background for each extra frame in the buffer below (65535 if no mask for this frame, 65534 if the mask is empty)
							UINT8*		BackgroundXMasks; // UINT16[nBXM*fW*fH/8] Design of the masks for backgrounds 1 bit per pixel
						if v>=15
							UINT8*		DynaShadowDirection;	// UINT8[nD * MAX_DYNA_SETS_PER_FRAMEN] Flags giving the direction of the dynamic content shadows, can be OR-ed
																// 0b1 - left, 0b10 - top left, 0b100 - top, 0b1000 - top right, 0b10000 - right, 0b100000 - bottom right, 0b1000000 - bottom, 0b10000000 - bottom left
							UINT16*		DynaShadowColor;	// UINT16[nD * MAX_DYNA_SETS_PER_FRAMEN] Color of the dynamic content shadows
							UINT8*		DynaShadowDirectionX;	// UINT8[nD * MAX_DYNA_SETS_PER_FRAMEN] Flags giving the direction of the dynamic content shadows for extra frame, can be OR-ed
																// 0b1 - left, 0b10 - top left, 0b100 - top, 0b1000 - top right, 0b10000 - right, 0b100000 - bottom right, 0b1000000 - bottom, 0b10000000 - bottom left
							UINT16*		DynaShadowColorX;	// UINT16[nD * MAX_DYNA_SETS_PER_FRAMEN] Color of the dynamic content shadows for extra frames
							if v>=18
								UINT16*     DynaSpriteMaskIDs; // UINT16[nS] Dynamic mask ID per sprite (65535 if no dynamic mask for this frame)
								UINT8*		DynaSpriteMasks;	// UINT8[nDS*fW*fH] Mask for dynamic content for each sprite.  The value (<MAX_DYNA_SETS_PER_FRAME) points to a sequence of 4/16 colors in DynaSprite4Cols. 255 means not a dynamic content.
								UINT16*		DynaSprite4Cols;	// UINT16[nDS*noC*MAX_DYNA_SETS_PER_SPRITE] noC colors per dynamic set
								UINT16*     DynaSpriteMaskIDs; // UINT16[nS] Dynamic mask ID per extra sprite (65535 if no dynamic mask for this frame)
								UINT8*		DynaSpriteMasksX;	// UINT8[nDSX*fW*fH] Mask for dynamic content for each extra sprite.  The value (<MAX_DYNA_SETS_PER_FRAME) points to a sequence of 4/16 colors in DynaSprite4ColsX. 255 means not a dynamic content.
								UINT16*		DynaSprite4ColsX;	// UINT16[nDSX*noC*MAX_DYNA_SETS_PER_SPRITE] noC colors per dynamic set
								if v>=19
									UINT8*		SpriteShapeMode; // UINT8[nS] is this sprite detected in shape mode?
	











